---- ip_input Matches (35 in 13 files) ----
Etharp.c (src\netif): * calling ip_input and passing ARP frames through etharp in ethernetif_input,
Etharp.c (src\netif):        ip_input(p, netif);      //去掉成功，ip输入函数处理数据
Icmp.c (src\core\ipv4): * Processes ICMP input packets, called from ip_input().
Icmp.c (src\core\ipv4): * Send an icmp 'destination unreachable' packet, called from ip_input() if
Igmp.c (src\core\ipv4): * Called from ip_input() if a new IGMP packet is received.
Ip.c (src\core\ipv4):ip_input(struct pbuf *p, struct netif *inp)   //处理收到的ip数据包
Ip.c (src\core\ipv4):      LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
Ip.c (src\core\ipv4):          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
Ip.c (src\core\ipv4):          LWIP_DEBUGF(IP_DEBUG, ("ip_input: LLA packet accepted on interface %c%c\n",
Ip.c (src\core\ipv4):      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
Ip.c (src\core\ipv4):        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
Ip.c (src\core\ipv4):      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
Ip.c (src\core\ipv4):    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: packet not for us.\n"));
Ip.c (src\core\ipv4):  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
Ip.c (src\core\ipv4):  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
Ip.h (src\include\ipv4\lwip):err_t ip_input(struct pbuf *p, struct netif *inp);
Ip.h (src\include\ipv6\lwip):void ip_input(struct pbuf *p, struct netif *inp);
Ip6.c (src\core\ipv6):    LWIP_DEBUGF(IP_DEBUG, ("ip_input: no forwarding route found for "));
Ip6.c (src\core\ipv6):/* ip_input:
Ip6.c (src\core\ipv6):ip_input(struct pbuf *p, struct netif *inp) {
Ip6.c (src\core\ipv6):    LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest "));
Ip6.c (src\core\ipv6):  /*  LWIP_DEBUGF("ip_input: \n");
Ip6.c (src\core\ipv6):  LWIP_DEBUGF("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len);*/
Ip6.c (src\core\ipv6):  PERF_STOP("ip_input");
Netif.c (src\core):  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, ip_input);
Netif.c (src\core):      if (ip_input(in, netif) != ERR_OK) {   //调用ip层数据包输入函数处理数据，发送一帧数据
Opt.h (src\include\lwip): * - called from ip_input() (IPv4)
Opt.h (src\include\lwip): * - pbuf: received struct pbuf passed to ip_input()
Ppp.c (src\netif\ppp):#include "lwip/ip.h" /* for ip_input() */
Ppp.c (src\netif\ppp):                  &pc->addrs.his_ipaddr, (void *)(size_t)pd, pppifNetifInit, ip_input)) {
Rawapi.txt (doc):  must use ip_input() declared in "lwip/ip.h".
Tcpip.c (src\api):        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
Tcpip.c (src\api):    ret = ip_input(p, inp);
Tcp_in.c (src\core): * These functions are generally called in the order (ip_input() ->)
Tcp_in.c (src\core): * ip_input()).
