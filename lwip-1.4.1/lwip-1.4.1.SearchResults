---- tcp_input Matches (68 in 11 files) ----
Ip.c (src\core\ipv4):      tcp_input(p, inp);
Ip6.c (src\core\ipv6):    tcp_input(p, inp);
Netif.c (src\core): * reentering non-reentrant functions like tcp_input(). Packets passed to
Opt.h (src\include\lwip): * tcp_input().
Tcp.c (src\core):  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
Tcp.c (src\core):    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
Tcp_helper.c (test\unit\tcp):/** Create a TCP segment usable for passing to tcp_input */
Tcp_helper.c (test\unit\tcp):/** Create a TCP segment usable for passing to tcp_input */
Tcp_helper.c (test\unit\tcp):/** Create a TCP segment usable for passing to tcp_input
Tcp_helper.c (test\unit\tcp):/** Create a TCP segment usable for passing to tcp_input
Tcp_helper.c (test\unit\tcp):/** Calls tcp_input() after adjusting current_iphdr_dest */
Tcp_helper.c (test\unit\tcp):  tcp_input(p, inp);
Tcp_impl.h (src\include\lwip):void             tcp_input   (struct pbuf *p, struct netif *inp);
Tcp_impl.h (src\include\lwip): * Some fields are converted to host byte order in tcp_input().
Tcp_in.c (src\core): * tcp_input() -> * tcp_process() -> tcp_receive() (-> application).
Tcp_in.c (src\core):   processing of TCP segments. They are set by the tcp_input()
Tcp_in.c (src\core):tcp_input(struct pbuf *p, struct netif *inp)
Tcp_in.c (src\core):    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
Tcp_in.c (src\core):      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
Tcp_in.c (src\core):    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
Tcp_in.c (src\core):    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
Tcp_in.c (src\core):    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
Tcp_in.c (src\core):    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
Tcp_in.c (src\core):      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
Tcp_in.c (src\core):      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
Tcp_in.c (src\core):      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
Tcp_in.c (src\core):        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
Tcp_in.c (src\core):      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
Tcp_in.c (src\core):  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
Tcp_in.c (src\core):            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
Tcp_in.c (src\core):    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
Tcp_in.c (src\core):  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
Tcp_in.c (src\core):  PERF_STOP("tcp_input");
Tcp_in.c (src\core): * Called by tcp_input() when a segment arrives for a listening
Tcp_in.c (src\core): * connection (from tcp_input()).
Tcp_in.c (src\core): * @note the return value is not (yet?) used in tcp_input()
Tcp_in.c (src\core): * Called by tcp_input() when a segment arrives for a connection in
Tcp_in.c (src\core): * Implements the TCP state machine. Called by tcp_input. In some
Tcp_in.c (src\core): * argument will be freed by the caller (tcp_input()) unless the
Tcp_in.c (src\core):      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
Tcp_out.c (src\core): * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
Tcp_out.c (src\core):  /* No need to call tcp_output: we are always called from tcp_input()
Test_tcp.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):/** create multiple segments and pass them to tcp_input in a wrong
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):/** create multiple segments and pass them to tcp_input in a wrong
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):/** create multiple segments and pass them to tcp_input with the first segment missing
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):  /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):  /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):    /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):  /* pass the segment to tcp_input */
Test_tcp_oos.c (test\unit\tcp):/** create multiple segments and pass them to tcp_input with the first segment missing
