---- tcp_enqueue_flags Matches (16 in 4 files) ----
Tcp.c (src\core):765
  ret = tcp_enqueue_flags(pcb, TCP_SYN);   //构造一个SYN=1的同步报文
Tcp_impl.h (src\include\lwip):440
err_t tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags);
Tcp_in.c (src\core):509
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);   //构造sys+ack报文
Tcp_out.c (src\core):141
  return tcp_enqueue_flags(pcb, TCP_FIN);
Tcp_out.c (src\core):147
 * Called by tcp_write and tcp_enqueue_flags.
Tcp_out.c (src\core):722
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)   //将数据放在发送缓冲队列中
Tcp_out.c (src\core):729
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
Tcp_out.c (src\core):731
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
Tcp_out.c (src\core):736
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
Tcp_out.c (src\core):753
  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
Tcp_out.c (src\core):758
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
Tcp_out.c (src\core):769
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
Tcp_out.c (src\core):779
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
Tcp_out.c (src\core):782
              ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
Tcp_out.c (src\core):812
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
Tcp_out.c (src\core):814
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
